<!doctype html>
<html lang="de">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Three.js – FP + Sky/Fog/Lights + Blocks + Raycast + Physics</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { overflow: hidden; font-family: system-ui, sans-serif; }

    #overlay {
      position: fixed; inset: 0; display: grid; place-items: center;
      background: rgba(0,0,0,.75); color: #fff; cursor: pointer; user-select: none;
      z-index: 10;
    }
    #overlay .panel {
      text-align: center; padding: 1rem 1.25rem;
      border: 1px solid rgba(255,255,255,.2); border-radius: 12px;
      background: rgba(0,0,0,.35);
    }
    #overlay h1 { margin: 0 0 .5rem; font-size: 1.25rem; }
    #overlay p  { margin: 0; opacity: .85; }

    /* Crosshair & HUD */
    #crosshair{
      position: fixed;
      left: 50%; top: 50%;
      width: 16px; height: 16px;
      margin-left: -8px; margin-top: -8px;
      pointer-events: none; opacity: .9;
    }
    #crosshair::before, #crosshair::after{
      content: ""; position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      background: #fff; border-radius: 1px;
    }
    #crosshair::before{ width: 14px; height: 2px; }
    #crosshair::after{  width: 2px;  height: 14px; }

    #hud{
      position: fixed; left: 12px; bottom: 12px;
      padding: .45rem .6rem; font: 12px/1.2 system-ui, sans-serif;
      color: #fff; background: rgba(0,0,0,.4);
      border: 1px solid rgba(255,255,255,.15); border-radius: 8px;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="overlay" tabindex="0" role="button" aria-label="Klick zum Starten">
    <div class="panel">
      <h1>Klick zum Starten</h1>
      <p>WASD: Bewegen · Space: Springen · Maus: Umschauen · Links: Block setzen · Rechts: Block entfernen · ESC: Entsperren</p>
    </div>
  </div>

  <div id="crosshair" aria-hidden="true"></div>
  <div id="hud">Block: <span id="hud-target">–</span></div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

    // Szene
    const scene = new THREE.Scene();

    // Himmel + Fog
    const skyColor = 0xEAF6FF;
    scene.fog = new THREE.Fog(skyColor, 12, 100);
    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(500, 32, 16),
      new THREE.MeshBasicMaterial({ color: skyColor, side: THREE.BackSide })
    );
    scene.add(sky);

    // Kamera
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.15;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // Licht
    const hemi = new THREE.HemisphereLight(0xffffff, 0xcfd8dc, 1.0);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 1.75);
    sun.position.set(8, 16, 6);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    const s = 30;
    sun.shadow.camera.left = -s; sun.shadow.camera.right = s;
    sun.shadow.camera.top = s;   sun.shadow.camera.bottom = -s;
    sun.shadow.camera.near = 0.5; sun.shadow.camera.far = 120;
    sun.shadow.bias = -0.0003;
    sun.shadow.normalBias = 0.04;
    scene.add(sun);

    scene.add(new THREE.AmbientLight(0xffffff, 0.15));

    // Boden
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(200, 200),
      new THREE.MeshStandardMaterial({ color: 0xE3F2FD, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    ground.userData.isGround = true;
    scene.add(ground);

    // PointerLockControls
    const controls = new PointerLockControls(camera, renderer.domElement);
    scene.add(controls.getObject());
    const overlay = document.getElementById('overlay');
    const hudTargetEl = document.getElementById('hud-target');
    overlay.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock',   () => { overlay.style.display = 'none'; });
    controls.addEventListener('unlock', () => { overlay.style.display = 'grid'; });

    // ====== Player-Physik-Parameter ==========================================
    const GROUND_HEIGHT = 1.0;
    const EYE_HEIGHT    = 1.0;
    const WALK_SPEED    = 5.0;
    const GRAVITY       = 22.0;
    const JUMP_SPEED    = 8.5;

    controls.getObject().position.set(0, GROUND_HEIGHT + EYE_HEIGHT, 8);

    const keys = { forward: false, backward: false, left: false, right: false };
    let wantJump = false;

    const onKeyDown = (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp':    keys.forward = true; break;
        case 'KeyS': case 'ArrowDown':  keys.backward = true; break;
        case 'KeyA': case 'ArrowLeft':  keys.left = true; break;
        case 'KeyD': case 'ArrowRight': keys.right = true; break;
        case 'Space': e.preventDefault(); wantJump = true; break;
      }
    };
    const onKeyUp = (e) => {
      switch (e.code) {
        case 'KeyW': case 'ArrowUp':    keys.forward = false; break;
        case 'KeyS': case 'ArrowDown':  keys.backward = false; break;
        case 'KeyA': case 'ArrowLeft':  keys.left = false; break;
        case 'KeyD': case 'ArrowRight': keys.right = false; break;
      }
    };
    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // ====== Blocks-Setup =====================================================

    const blockGeo = new THREE.BoxGeometry(1, 1, 1);

    // Gras-Textur (normal, kein Pixel-Look)
    const texLoader = new THREE.TextureLoader();
    const grassTex = texLoader.load(
      "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/terrain/grasslight-big.jpg"
    );
    grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
    grassTex.anisotropy = renderer.capabilities.getMaxAnisotropy();

    function randomTint() {
      return new THREE.Color().setHSL(Math.random(), 0.35, 0.65);
    }

    const blockIndex = new Map();
    const columnTops = new Map();
    const keyOf = (pos) => `${pos.x},${pos.y},${pos.z}`;
    const colKey = (x, z) => `${x},${z}`;

    function colAddTop(x, z, topY) {
      const k = colKey(x, z);
      const arr = columnTops.get(k) || [];
      arr.push(topY);
      columnTops.set(k, arr);
    }
    function colRemoveTop(x, z, topY) {
      const k = colKey(x, z);
      const arr = columnTops.get(k);
      if (!arr) return;
      const idx = arr.indexOf(topY);
      if (idx !== -1) arr.splice(idx, 1);
      if (arr.length) columnTops.set(k, arr);
      else columnTops.delete(k);
    }
    function highestTopAt(x, z) {
      const arr = columnTops.get(colKey(x, z));
      if (!arr || !arr.length) return GROUND_HEIGHT;
      let m = arr[0];
      for (let i = 1; i < arr.length; i++) if (arr[i] > m) m = arr[i];
      return m;
    }

    function addBlock(position) {
      const base = { x: Math.round(position.x), y: Math.round(position.y), z: Math.round(position.z) };
      const k = keyOf(base);
      if (blockIndex.has(k)) return blockIndex.get(k);

      const mat = new THREE.MeshStandardMaterial({
        map: grassTex,
        color: randomTint(),
        metalness: 0.05,
        roughness: 0.85
      });

      const block = new THREE.Mesh(blockGeo, mat);
      block.castShadow = true;
      block.receiveShadow = true;
      block.position.set(base.x, base.y + 0.5, base.z);
      block.userData.isBlock = true;
      block.userData.base = base;

      scene.add(block);
      blockIndex.set(k, block);
      colAddTop(base.x, base.z, base.y + 1.0);
      return block;
    }

    function removeBlockByMesh(mesh) {
      if (!mesh?.userData?.isBlock) return;
      const base = mesh.userData.base;
      const k = keyOf(base);
      scene.remove(mesh);
      mesh.material?.dispose?.();
      blockIndex.delete(k);
      colRemoveTop(base.x, base.z, base.y + 1.0);
    }

    for (let ix = -10; ix < 10; ix++) {
      for (let iz = -10; iz < 10; iz++) {
        addBlock({ x: ix, y: 0, z: iz });
      }
    }

    // ====== Raycasting ======================================================
    const raycaster = new THREE.Raycaster();
    const centerNDC = new THREE.Vector2(0, 0);

    function raycastFromCamera() {
      raycaster.setFromCamera(centerNDC, camera);
      const candidates = [ground, ...Array.from(blockIndex.values())];
      const intersects = raycaster.intersectObjects(candidates, false);
      return intersects[0] || null;
    }

    function aimedBaseFromHit(hit){
      if (hit.object.userData?.isBlock) return hit.object.userData.base;
      if (hit.object.userData?.isGround) {
        const p = hit.point;
        return { x: Math.round(p.x), y: 0, z: Math.round(p.z) };
      }
      return null;
    }

    function updateHUD(){
      const hit = raycastFromCamera();
      if (!hit) { hudTargetEl.textContent = "–"; return; }
      const base = aimedBaseFromHit(hit);
      hudTargetEl.textContent = base ? `x:${base.x} y:${base.y} z:${base.z}` : "–";
    }

    document.addEventListener('contextmenu', (e) => e.preventDefault());

    document.addEventListener('mousedown', (e) => {
      if (!controls.isLocked) return;
      const hit = raycastFromCamera();
      if (!hit) return;
      if (e.button === 0) {
        const obj = hit.object;
        if (obj.userData.isBlock) {
          const normalWorld = hit.face.normal.clone().transformDirection(obj.matrixWorld);
          const targetCenter = obj.position.clone().add(normalWorld);
          const base = {
            x: Math.round(targetCenter.x),
            y: Math.round(targetCenter.y - 0.5),
            z: Math.round(targetCenter.z),
          };
          addBlock(base);
        } else if (obj.userData.isGround) {
          const p = hit.point.clone();
          const base = { x: Math.round(p.x), y: 0, z: Math.round(p.z) };
          addBlock(base);
        }
      }
      if (e.button === 2) {
        if (hit.object.userData.isBlock) {
          removeBlockByMesh(hit.object);
        }
      }
    });

    // ====== Physik ==========================================================
    let vY = 0;
    let onGround = false;

    function updatePlayerPhysics(delta){
      const obj = controls.getObject();
      let mx = (keys.right ? 1 : 0) - (keys.left ? 1 : 0);
      let mz = (keys.forward ? 1 : 0) - (keys.backward ? 1 : 0);
      if (mx || mz) {
        const len = Math.hypot(mx, mz);
        mx /= len; mz /= len;
        controls.moveRight(mx * WALK_SPEED * delta);
        controls.moveForward(mz * WALK_SPEED * delta);
      }
      if (wantJump && onGround) vY = JUMP_SPEED;
      wantJump = false;
      vY -= GRAVITY * delta;
      obj.position.y += vY * delta;
      const gx = Math.round(obj.position.x);
      const gz = Math.round(obj.position.z);
      const groundTop = highestTopAt(gx, gz);
      const minY = groundTop + EYE_HEIGHT;
      if (obj.position.y < minY) {
        obj.position.y = minY;
        vY = 0;
        onGround = true;
      } else {
        onGround = false;
      }
    }

    // ====== Loop ============================================================
    let prev = performance.now();
    function animate() {
      const now = performance.now();
      const delta = Math.min((now - prev) / 1000, 0.05);
      prev = now;
      if (controls.isLocked) updatePlayerPhysics(delta);
      updateHUD();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>

</html>
